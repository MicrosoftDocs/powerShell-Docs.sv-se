---
title: Allt du ville veta om undantag
description: Fel hanteringen är bara en del av livs cykeln när den kommer att skriva kod.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: cd17ae6b5ded052c93923b648155a4dda8956b34
ms.sourcegitcommit: 94c39b0d36b948d3a62707ae8a3be00efe606434
ms.translationtype: MT
ms.contentlocale: sv-SE
ms.lasthandoff: 09/11/2020
ms.locfileid: "90012569"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="ddad9-103">Allt du ville veta om undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="ddad9-104">Fel hanteringen är bara en del av livs cykeln när den kommer att skriva kod.</span><span class="sxs-lookup"><span data-stu-id="ddad9-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="ddad9-105">Vi kan ofta kontrol lera och validera villkor för förväntat beteende.</span><span class="sxs-lookup"><span data-stu-id="ddad9-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="ddad9-106">När det oväntade inträffar aktiverar vi undantags hantering.</span><span class="sxs-lookup"><span data-stu-id="ddad9-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="ddad9-107">Du kan enkelt hantera undantag som skapats av andra personers kod eller så kan du skapa egna undantag för andra att hantera.</span><span class="sxs-lookup"><span data-stu-id="ddad9-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="ddad9-108">Den [ursprungliga versionen][] av den här artikeln visas på bloggen som skrivits av [@KevinMarquette][] .</span><span class="sxs-lookup"><span data-stu-id="ddad9-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="ddad9-109">PowerShell-teamet tackar för att dela det här innehållet med oss.</span><span class="sxs-lookup"><span data-stu-id="ddad9-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="ddad9-110">Ta en titt på hans blogg på [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="ddad9-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="ddad9-111">Grundläggande terminologi</span><span class="sxs-lookup"><span data-stu-id="ddad9-111">Basic terminology</span></span>

<span data-ttu-id="ddad9-112">Vi måste behandla några grundläggande villkor innan vi hoppar till den här.</span><span class="sxs-lookup"><span data-stu-id="ddad9-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="ddad9-113">Undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-113">Exception</span></span>

<span data-ttu-id="ddad9-114">Ett undantag är som en händelse som skapas när normal fel hantering inte kan hantera problemet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="ddad9-115">Att försöka dividera ett tal med noll eller slut på minne är några exempel på något som skapar ett undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="ddad9-116">Ibland kan författaren till den kod som du använder skapa undantag för vissa problem när de inträffar.</span><span class="sxs-lookup"><span data-stu-id="ddad9-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="ddad9-117">Throw och catch</span><span class="sxs-lookup"><span data-stu-id="ddad9-117">Throw and Catch</span></span>

<span data-ttu-id="ddad9-118">När ett undantag inträffar säger vi att ett undantag uppstår.</span><span class="sxs-lookup"><span data-stu-id="ddad9-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="ddad9-119">För att hantera ett utlöst undantag måste du fånga det.</span><span class="sxs-lookup"><span data-stu-id="ddad9-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="ddad9-120">Om ett undantags fel uppstår och det inte fångas av något, slutar skriptet att köras.</span><span class="sxs-lookup"><span data-stu-id="ddad9-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="ddad9-121">Anrops stacken</span><span class="sxs-lookup"><span data-stu-id="ddad9-121">The call stack</span></span>

<span data-ttu-id="ddad9-122">Anrops stacken är en lista över funktioner som har anropat varandra.</span><span class="sxs-lookup"><span data-stu-id="ddad9-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="ddad9-123">När en funktion anropas läggs den till i stacken eller överst i listan.</span><span class="sxs-lookup"><span data-stu-id="ddad9-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="ddad9-124">När funktionen avslutas eller returneras tas den bort från stacken.</span><span class="sxs-lookup"><span data-stu-id="ddad9-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="ddad9-125">När ett undantag genereras, kontrol leras anrops stacken för att en undantags hanterare ska kunna fånga den.</span><span class="sxs-lookup"><span data-stu-id="ddad9-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="ddad9-126">Avbryta och icke-avslutande fel</span><span class="sxs-lookup"><span data-stu-id="ddad9-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="ddad9-127">Ett undantag är vanligt vis ett avslutande fel.</span><span class="sxs-lookup"><span data-stu-id="ddad9-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="ddad9-128">Ett utlöst undantag har antingen fångats upp eller avslutar den aktuella körningen.</span><span class="sxs-lookup"><span data-stu-id="ddad9-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="ddad9-129">Som standard genereras ett icke-avslutande fel av `Write-Error` och ett fel läggs till i utdataströmmen utan att ett undantag utlöses.</span><span class="sxs-lookup"><span data-stu-id="ddad9-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="ddad9-130">Jag pekar `Write-Error` på detta, eftersom andra icke-avslutande fel inte utlöser `catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="ddad9-131">Förtäring av undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-131">Swallowing an exception</span></span>

<span data-ttu-id="ddad9-132">Detta är när du fångar ett fel bara för att ignorera det.</span><span class="sxs-lookup"><span data-stu-id="ddad9-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="ddad9-133">Gör detta med försiktighet eftersom det kan göra fel söknings problem mycket svårt.</span><span class="sxs-lookup"><span data-stu-id="ddad9-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="ddad9-134">Basic-kommandosyntax</span><span class="sxs-lookup"><span data-stu-id="ddad9-134">Basic command syntax</span></span>

<span data-ttu-id="ddad9-135">Här är en snabb översikt över den grundläggande syntaxen för undantags hantering som används i PowerShell.</span><span class="sxs-lookup"><span data-stu-id="ddad9-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="ddad9-136">Genereras</span><span class="sxs-lookup"><span data-stu-id="ddad9-136">Throw</span></span>

<span data-ttu-id="ddad9-137">För att skapa en egen undantags händelse genererar vi ett undantag med `throw` nyckelordet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="ddad9-138">Detta skapar ett körnings undantag som är ett avbrotts fel.</span><span class="sxs-lookup"><span data-stu-id="ddad9-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="ddad9-139">Den hanteras av en `catch` i en anropande funktion eller avslutar skriptet med ett meddelande som detta.</span><span class="sxs-lookup"><span data-stu-id="ddad9-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="ddad9-140">Skriv-Error-ErrorAction-stopp</span><span class="sxs-lookup"><span data-stu-id="ddad9-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="ddad9-141">Jag nämnde att det `Write-Error` inte uppstår något avslutande fel som standard.</span><span class="sxs-lookup"><span data-stu-id="ddad9-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="ddad9-142">Om du anger `-ErrorAction Stop` `Write-Error` genererar ett avslutande fel som kan hanteras med en `catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="ddad9-143">Tack för att du Pettersson Dailey för att påminna om hur du använder `-ErrorAction Stop` det här sättet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="ddad9-144">Cmdlet-ErrorAction-stopp</span><span class="sxs-lookup"><span data-stu-id="ddad9-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="ddad9-145">Om du anger `-ErrorAction Stop` en avancerad funktion eller cmdlet, aktiverar den alla `Write-Error` instruktioner för att avsluta fel som slutar att köras eller som kan hanteras av en `catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="ddad9-146">Prova/fånga</span><span class="sxs-lookup"><span data-stu-id="ddad9-146">Try/Catch</span></span>

<span data-ttu-id="ddad9-147">Hur undantags hanteringen fungerar i PowerShell (och många andra språk) är att du först är `try` en del av koden och om den genererar ett fel, så kan du `catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="ddad9-148">Här är ett snabbt exempel.</span><span class="sxs-lookup"><span data-stu-id="ddad9-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="ddad9-149">`catch`Skriptet körs bara om det finns ett avslutande fel.</span><span class="sxs-lookup"><span data-stu-id="ddad9-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="ddad9-150">Om `try` körningen är korrekt hoppar den över `catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="ddad9-151">Try/finally</span><span class="sxs-lookup"><span data-stu-id="ddad9-151">Try/Finally</span></span>

<span data-ttu-id="ddad9-152">Ibland behöver du inte hantera ett fel men ändå behöver en kod för att köras om ett undantag inträffar eller inte.</span><span class="sxs-lookup"><span data-stu-id="ddad9-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="ddad9-153">Ett `finally` skript gör exakt det.</span><span class="sxs-lookup"><span data-stu-id="ddad9-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="ddad9-154">Ta en titt på det här exemplet:</span><span class="sxs-lookup"><span data-stu-id="ddad9-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="ddad9-155">När du öppnar eller ansluter till en resurs ska du stänga den.</span><span class="sxs-lookup"><span data-stu-id="ddad9-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="ddad9-156">Om `ExecuteNonQuery()` ett undantag utlöses stängs inte anslutningen.</span><span class="sxs-lookup"><span data-stu-id="ddad9-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="ddad9-157">Här är samma kod inuti ett `try/finally` block.</span><span class="sxs-lookup"><span data-stu-id="ddad9-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="ddad9-158">I det här exemplet stängs anslutningen om det uppstår ett fel.</span><span class="sxs-lookup"><span data-stu-id="ddad9-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="ddad9-159">Den stängs också om det inte finns något fel.</span><span class="sxs-lookup"><span data-stu-id="ddad9-159">It also is closed if there's no error.</span></span> <span data-ttu-id="ddad9-160">`finally`Skriptet körs varje gång.</span><span class="sxs-lookup"><span data-stu-id="ddad9-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="ddad9-161">Eftersom du inte fångar undantaget, kommer det fortfarande att spridas till anrops stacken.</span><span class="sxs-lookup"><span data-stu-id="ddad9-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="ddad9-162">Try/catch/finally</span><span class="sxs-lookup"><span data-stu-id="ddad9-162">Try/Catch/Finally</span></span>

<span data-ttu-id="ddad9-163">Den är perfekt giltig att användas `catch` och `finally` tillsammans.</span><span class="sxs-lookup"><span data-stu-id="ddad9-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="ddad9-164">I de flesta fall kommer du att använda en av de andra, men du kan hitta scenarier där du använder båda.</span><span class="sxs-lookup"><span data-stu-id="ddad9-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="ddad9-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="ddad9-165">$PSItem</span></span>

<span data-ttu-id="ddad9-166">Nu när vi har lärt dig grunderna, kan vi göra en aning djupare.</span><span class="sxs-lookup"><span data-stu-id="ddad9-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="ddad9-167">Inuti `catch` blocket finns en automatisk variabel ( `$PSItem` eller `$_` ) av typen `ErrorRecord` som innehåller information om undantaget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="ddad9-168">Här är en snabb översikt över några av nyckel egenskaperna.</span><span class="sxs-lookup"><span data-stu-id="ddad9-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="ddad9-169">I de här exemplen använde jag en ogiltig sökväg i `ReadAllText` för att generera detta undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="ddad9-170">PSItem. ToString ()</span><span class="sxs-lookup"><span data-stu-id="ddad9-170">PSItem.ToString()</span></span>

<span data-ttu-id="ddad9-171">Detta ger dig det rensade meddelande som ska användas vid loggning och allmänna utdata.</span><span class="sxs-lookup"><span data-stu-id="ddad9-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="ddad9-172">`ToString()` anropas automatiskt om `$PSItem` är placerad inuti en sträng.</span><span class="sxs-lookup"><span data-stu-id="ddad9-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="ddad9-173">$PSItem. InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="ddad9-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="ddad9-174">Den här egenskapen innehåller ytterligare information som samlas in av PowerShell om funktionen eller skriptet där undantaget uppstod.</span><span class="sxs-lookup"><span data-stu-id="ddad9-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="ddad9-175">Här är `InvocationInfo` från det exempel-undantag som jag skapade.</span><span class="sxs-lookup"><span data-stu-id="ddad9-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="ddad9-176">Den viktiga informationen här visar `ScriptName` , `Line` koden och `ScriptLineNumber` var anropet startades.</span><span class="sxs-lookup"><span data-stu-id="ddad9-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="ddad9-177">$PSItem. ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="ddad9-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="ddad9-178">Den här egenskapen visar ordningen på funktions anrop som har fått till gång till koden där undantaget genererades.</span><span class="sxs-lookup"><span data-stu-id="ddad9-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="ddad9-179">Jag gör bara anrop till funktioner i samma skript, men detta spårar anropen om flera skript var involverade.</span><span class="sxs-lookup"><span data-stu-id="ddad9-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="ddad9-180">$PSItem. Exception</span><span class="sxs-lookup"><span data-stu-id="ddad9-180">$PSItem.Exception</span></span>

<span data-ttu-id="ddad9-181">Detta är det faktiska undantaget som utlöstes.</span><span class="sxs-lookup"><span data-stu-id="ddad9-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="ddad9-182">$PSItem. Exception. Message</span><span class="sxs-lookup"><span data-stu-id="ddad9-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="ddad9-183">Detta är det allmänna meddelandet som beskriver undantaget och är en korrekt start punkt vid fel sökning.</span><span class="sxs-lookup"><span data-stu-id="ddad9-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="ddad9-184">De flesta undantag har ett standard meddelande men kan också ställas in på något anpassat när undantaget genereras.</span><span class="sxs-lookup"><span data-stu-id="ddad9-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="ddad9-185">Detta är även det meddelande som returneras vid anrop `$PSItem.ToString()` om det inte fanns någon uppsättning på `ErrorRecord` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="ddad9-186">$PSItem. Exception. InnerException</span><span class="sxs-lookup"><span data-stu-id="ddad9-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="ddad9-187">Undantag kan innehålla inre undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="ddad9-188">Detta är ofta fallet när den kod som du anropar fångar ett undantag och genererar ett annat undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="ddad9-189">Det ursprungliga undantaget placeras inuti det nya undantaget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="ddad9-190">Jag går tillbaka senare när jag pratar om undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="ddad9-191">$PSItem. Exception. StackTrace</span><span class="sxs-lookup"><span data-stu-id="ddad9-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="ddad9-192">Detta är `StackTrace` för undantaget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="ddad9-193">Jag visade en `ScriptStackTrace` ovan, men det här är ett för anrop till hanterad kod.</span><span class="sxs-lookup"><span data-stu-id="ddad9-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="ddad9-194">Du får bara den här stack spårningen när händelsen genereras från hanterad kod.</span><span class="sxs-lookup"><span data-stu-id="ddad9-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="ddad9-195">Jag anropar en .NET Framework-funktion direkt så att vi kan se det i det här exemplet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="ddad9-196">Vanligt vis när du tittar på en stack spårning är du säker på var koden stoppas och system anropen börjar.</span><span class="sxs-lookup"><span data-stu-id="ddad9-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="ddad9-197">Arbeta med undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-197">Working with exceptions</span></span>

<span data-ttu-id="ddad9-198">Det finns fler undantag än grundläggande syntax och undantags egenskaper.</span><span class="sxs-lookup"><span data-stu-id="ddad9-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="ddad9-199">Fångst av skrivna undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-199">Catching typed exceptions</span></span>

<span data-ttu-id="ddad9-200">Du kan vara selektiv med de undantag som du har fångat.</span><span class="sxs-lookup"><span data-stu-id="ddad9-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="ddad9-201">Undantag har en typ och du kan ange vilken typ av undantag du vill fånga.</span><span class="sxs-lookup"><span data-stu-id="ddad9-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="ddad9-202">Undantags typen kontrol leras för varje `catch` block tills ett hittas som matchar ditt undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="ddad9-203">Det är viktigt att du inser att undantag kan ärva från andra undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="ddad9-204">I exemplet ovan `FileNotFoundException` ärver från `IOException` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="ddad9-205">Så om du `IOException` först var det skulle den anropas i stället.</span><span class="sxs-lookup"><span data-stu-id="ddad9-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="ddad9-206">Endast ett catch-block anropas även om det finns flera matchningar.</span><span class="sxs-lookup"><span data-stu-id="ddad9-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="ddad9-207">Om vi hade ett `System.IO.PathTooLongException` , `IOException` skulle det matcha, men om vi hade ett så skulle vi inte `InsufficientMemoryException` fånga det och det skulle spridas i stacken.</span><span class="sxs-lookup"><span data-stu-id="ddad9-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="ddad9-208">Fånga flera typer samtidigt</span><span class="sxs-lookup"><span data-stu-id="ddad9-208">Catch multiple types at once</span></span>

<span data-ttu-id="ddad9-209">Det är möjligt att fånga flera undantags typer med samma `catch` instruktion.</span><span class="sxs-lookup"><span data-stu-id="ddad9-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="ddad9-210">Tack för att du `/u/Sheppard_Ra` föreslår det här tillägget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="ddad9-211">Utlös ande undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-211">Throwing typed exceptions</span></span>

<span data-ttu-id="ddad9-212">Du kan kasta skrivna undantag i PowerShell.</span><span class="sxs-lookup"><span data-stu-id="ddad9-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="ddad9-213">I stället för att anropa `throw` med en sträng:</span><span class="sxs-lookup"><span data-stu-id="ddad9-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="ddad9-214">Använd en undantags Accelerator så här:</span><span class="sxs-lookup"><span data-stu-id="ddad9-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="ddad9-215">Men du måste ange ett meddelande när du gör det på det sättet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="ddad9-216">Du kan också skapa en ny instans av ett undantag som ska genereras.</span><span class="sxs-lookup"><span data-stu-id="ddad9-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="ddad9-217">Meddelandet är valfritt när du gör detta eftersom systemet innehåller standard meddelanden för alla inbyggda undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="ddad9-218">Om du inte använder PowerShell 5,0 eller senare måste du använda den äldre `New-Object` metoden.</span><span class="sxs-lookup"><span data-stu-id="ddad9-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="ddad9-219">Genom att använda ett inskrivet undantag kan du (eller andra) fånga undantagen enligt den typ som anges i föregående avsnitt.</span><span class="sxs-lookup"><span data-stu-id="ddad9-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="ddad9-220">Skriv-Error-Exception</span><span class="sxs-lookup"><span data-stu-id="ddad9-220">Write-Error -Exception</span></span>

<span data-ttu-id="ddad9-221">Vi kan lägga till de här skrivna undantagen i `Write-Error` och vi kan fortfarande `catch` fel efter undantags typ.</span><span class="sxs-lookup"><span data-stu-id="ddad9-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="ddad9-222">Använd `Write-Error` som i följande exempel:</span><span class="sxs-lookup"><span data-stu-id="ddad9-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="ddad9-223">Sedan kan vi fånga den så här:</span><span class="sxs-lookup"><span data-stu-id="ddad9-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="ddad9-224">Den stora listan med .NET-undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="ddad9-225">Jag har kompilerat en huvud lista med hjälp av [Reddit/r/PowerShell-communityn][] som innehåller hundratals .net-undantag för att komplettera det här inlägget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="ddad9-226">[Den stora listan med .NET-undantag][]</span><span class="sxs-lookup"><span data-stu-id="ddad9-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="ddad9-227">Jag börjar med att söka i listan efter undantag som ser ut som att de passar bra för min situation.</span><span class="sxs-lookup"><span data-stu-id="ddad9-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="ddad9-228">Du bör försöka använda undantag i bas `System` namn området.</span><span class="sxs-lookup"><span data-stu-id="ddad9-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="ddad9-229">Undantag är objekt</span><span class="sxs-lookup"><span data-stu-id="ddad9-229">Exceptions are objects</span></span>

<span data-ttu-id="ddad9-230">Om du börjar använda flera skrivna undantag, kom ihåg att de är objekt.</span><span class="sxs-lookup"><span data-stu-id="ddad9-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="ddad9-231">Olika undantag har olika konstruktorer och egenskaper.</span><span class="sxs-lookup"><span data-stu-id="ddad9-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="ddad9-232">Om vi tittar på [FileNotFoundException][] -dokumentationen för `System.IO.FileNotFoundException` ser vi att vi kan skicka i ett meddelande och en fil Sök väg.</span><span class="sxs-lookup"><span data-stu-id="ddad9-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="ddad9-233">Och har en `FileName` egenskap som visar fil Sök vägen.</span><span class="sxs-lookup"><span data-stu-id="ddad9-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="ddad9-234">Du bör läsa [.net-dokumentationen][] för andra konstruktörer och objekt egenskaper.</span><span class="sxs-lookup"><span data-stu-id="ddad9-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="ddad9-235">Återskapar ett undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-235">Re-throwing an exception</span></span>

<span data-ttu-id="ddad9-236">Om allt du kommer att göra i `catch` blockeringen är `throw` samma undantag `catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="ddad9-237">Du bör bara ha `catch` ett undantag som du planerar att hantera eller utföra en åtgärd när det händer.</span><span class="sxs-lookup"><span data-stu-id="ddad9-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="ddad9-238">Det finns tillfällen när du vill utföra en åtgärd i ett undantag, men som återskapar undantaget så att något går ut i förhållande till det.</span><span class="sxs-lookup"><span data-stu-id="ddad9-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="ddad9-239">Vi kan skriva ett meddelande eller logga problemet nära den plats där vi upptäcker det men hantera problemet ytterligare i stacken.</span><span class="sxs-lookup"><span data-stu-id="ddad9-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="ddad9-240">Vi är tillräckligt intressant och kan anropa inifrån `throw` `catch` och återskapar det aktuella undantaget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="ddad9-241">Vi vill återställa undantaget för att bevara den ursprungliga körnings informationen som käll skript och rad nummer.</span><span class="sxs-lookup"><span data-stu-id="ddad9-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="ddad9-242">Om vi genererar ett nytt undantag i det här läget, döljs var undantaget startades.</span><span class="sxs-lookup"><span data-stu-id="ddad9-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="ddad9-243">Återskapa ett nytt undantag</span><span class="sxs-lookup"><span data-stu-id="ddad9-243">Re-throwing a new exception</span></span>

<span data-ttu-id="ddad9-244">Om du fångar ett undantag, men vill kasta ett annat, ska du kapsla det ursprungliga undantaget inuti det nya.</span><span class="sxs-lookup"><span data-stu-id="ddad9-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="ddad9-245">På så sätt kan någon av stackarna få till gång till den som `$PSItem.Exception.InnerException` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="ddad9-246">$PSCmdlet. ThrowTerminatingError ()</span><span class="sxs-lookup"><span data-stu-id="ddad9-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="ddad9-247">En sak som jag inte vill använda `throw` för obehandlade undantag är att fel meddelandet pekar på `throw` instruktionen och indikerar att raden är den plats där problemet finns.</span><span class="sxs-lookup"><span data-stu-id="ddad9-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="ddad9-248">Om du får ett fel meddelande om att mitt skript är brutet, eftersom jag har anropat `throw` på rad 31 är ett dåligt meddelande för användare av ditt skript att se.</span><span class="sxs-lookup"><span data-stu-id="ddad9-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="ddad9-249">Det ser inte ut som om det är något användbart.</span><span class="sxs-lookup"><span data-stu-id="ddad9-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="ddad9-250">Dhami påpekade att jag kan använda `ThrowTerminatingError()` för att åtgärda detta.</span><span class="sxs-lookup"><span data-stu-id="ddad9-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="ddad9-251">Om vi antar att `ThrowTerminatingError()` anropades inuti en funktion som kallas `Get-Resource` , är det här felet som vi skulle se.</span><span class="sxs-lookup"><span data-stu-id="ddad9-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="ddad9-252">Ser du hur det pekar på `Get-Resource` funktionen som orsaken till problemet?</span><span class="sxs-lookup"><span data-stu-id="ddad9-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="ddad9-253">Detta talar om för användaren något användbart.</span><span class="sxs-lookup"><span data-stu-id="ddad9-253">That tells the user something useful.</span></span>

<span data-ttu-id="ddad9-254">Eftersom `$PSItem` är en `ErrorRecord` kan vi även använda `ThrowTerminatingError` det här sättet för att utlösa igen.</span><span class="sxs-lookup"><span data-stu-id="ddad9-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="ddad9-255">Detta ändrar källan till felet till cmdleten och döljer de interna funktionerna från användarna av din cmdlet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="ddad9-256">Försök att skapa avslutande fel</span><span class="sxs-lookup"><span data-stu-id="ddad9-256">Try can create terminating errors</span></span>

<span data-ttu-id="ddad9-257">Kirks Munro pekar ut om att vissa undantag endast avslutar fel när de körs inuti ett `try/catch` block.</span><span class="sxs-lookup"><span data-stu-id="ddad9-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="ddad9-258">Här är exemplet han fick mig som genererade ett divisions fel med körnings undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="ddad9-259">Sedan anropar du det som det här för att se hur det genererar felet och fortsätter att skriva ut meddelandet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="ddad9-260">Men genom att placera samma kod inuti en `try/catch` , ser vi något annat.</span><span class="sxs-lookup"><span data-stu-id="ddad9-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="ddad9-261">Vi ser felet blir ett avbrotts fel och ger inte ut det första meddelandet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="ddad9-262">Vad jag inte tycker om det här är att du kan ha den här koden i en funktion och den fungerar annorlunda om någon använder en `try/catch` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="ddad9-263">Jag har inte stött på problem med det här, men det är ett hörn fall som är medvetet om.</span><span class="sxs-lookup"><span data-stu-id="ddad9-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="ddad9-264">$PSCmdlet. ThrowTerminatingError () inuti try/catch</span><span class="sxs-lookup"><span data-stu-id="ddad9-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="ddad9-265">En Nuance av `$PSCmdlet.ThrowTerminatingError()` är att den skapar ett avbrotts fel i din cmdlet, men det går in i ett icke-avslutande fel när cmdleten har lämnat din cmdlet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="ddad9-266">Detta gör att den som anropar en funktion kan hantera felet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="ddad9-267">De kan ändra tillbaka till ett avslutande fel genom att använda `-ErrorAction Stop` eller anropa det inifrån en `try{...}catch{...}` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="ddad9-268">Mallar för offentliga funktioner</span><span class="sxs-lookup"><span data-stu-id="ddad9-268">Public function templates</span></span>

<span data-ttu-id="ddad9-269">Ett sista sätt att använda min konversation med Kirks Munro var att han var `try{...}catch{...}` runt varje `begin` , `process` och `end` blockerar i alla sina avancerade funktioner.</span><span class="sxs-lookup"><span data-stu-id="ddad9-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="ddad9-270">I dessa generiska catch-block har han en enda linje `$PSCmdlet.ThrowTerminatingError($PSItem)` som använder för att hantera alla undantag som lämnar sina uppgifter.</span><span class="sxs-lookup"><span data-stu-id="ddad9-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="ddad9-271">Eftersom allt är i en `try` instruktion inom sina funktioner fungerar allt konsekvent.</span><span class="sxs-lookup"><span data-stu-id="ddad9-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="ddad9-272">Detta ger också rena fel till slutanvändaren som döljer den interna koden från det genererade felet.</span><span class="sxs-lookup"><span data-stu-id="ddad9-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="ddad9-273">Väll</span><span class="sxs-lookup"><span data-stu-id="ddad9-273">Trap</span></span>

<span data-ttu-id="ddad9-274">Jag fokuserar på `try/catch` aspekten av undantag.</span><span class="sxs-lookup"><span data-stu-id="ddad9-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="ddad9-275">Men det finns en äldre funktion jag måste säga innan vi kan packa upp den här.</span><span class="sxs-lookup"><span data-stu-id="ddad9-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="ddad9-276">En `trap` placeras i ett skript eller en funktion för att fånga alla undantag som inträffar i det aktuella omfånget.</span><span class="sxs-lookup"><span data-stu-id="ddad9-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="ddad9-277">När ett undantag inträffar fortsätter koden i att `trap` köras och sedan fortsätter den normala koden.</span><span class="sxs-lookup"><span data-stu-id="ddad9-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="ddad9-278">Om flera undantag inträffar anropas trapen över och över.</span><span class="sxs-lookup"><span data-stu-id="ddad9-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="ddad9-279">Jag har aldrig tillfrågat den här metoden, men jag kan se värdet i administratörs-eller kontrollantens skript som loggar alla eventuella undantag och fortfarande fortsätta att köra.</span><span class="sxs-lookup"><span data-stu-id="ddad9-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="ddad9-280">Avslutande anmärkningar</span><span class="sxs-lookup"><span data-stu-id="ddad9-280">Closing remarks</span></span>

<span data-ttu-id="ddad9-281">Genom att lägga till korrekt undantags hantering i dina skript kan du inte bara göra dem mer stabila, utan även göra det enklare för dig att felsöka undantagen.</span><span class="sxs-lookup"><span data-stu-id="ddad9-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="ddad9-282">Jag har ägnat mycket tid åt `throw` att prata eftersom det är ett Core-koncept när vi pratar om undantags hantering.</span><span class="sxs-lookup"><span data-stu-id="ddad9-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="ddad9-283">PowerShell gav också oss `Write-Error` som hanterar alla situationer där du skulle använda `throw` .</span><span class="sxs-lookup"><span data-stu-id="ddad9-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="ddad9-284">Tänk på att du inte behöver använda `throw` det när du har läst det här.</span><span class="sxs-lookup"><span data-stu-id="ddad9-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="ddad9-285">Nu när jag har tagit tid att skriva om undantags hantering i den här informationen ska jag växla över till `Write-Error -Stop` att använda för att generera fel i koden.</span><span class="sxs-lookup"><span data-stu-id="ddad9-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="ddad9-286">Jag ska också ta Kirks-råd och göra `ThrowTerminatingError` min goto undantags hanterare för varje funktion.</span><span class="sxs-lookup"><span data-stu-id="ddad9-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[ursprunglig version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell-community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Den stora listan med .NET-undantag]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[.NET-dokumentation]: /dotnet/api
[.NET documentation]: /dotnet/api
